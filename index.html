<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Vortex: Deep Tunnel</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            cursor: crosshair;
            touch-action: none; 
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
        }
        .hud-text {
            color: #00ffff;
            font-size: 20px;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.8);
            letter-spacing: 2px;
            font-weight: 600;
        }
        #score-container { text-align: left; }
        #lives-container { text-align: right; }
        
        #game-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(10, 10, 20, 0.9);
            padding: 40px 60px;
            border: 1px solid #00ffff;
            border-radius: 4px;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.2);
            pointer-events: auto;
            z-index: 10;
            backdrop-filter: blur(10px);
            width: 85%;
            max-width: 500px;
            box-sizing: border-box;
        }
        h1 {
            color: #fff;
            margin: 0 0 10px 0;
            font-size: 48px;
            letter-spacing: 10px;
            text-transform: uppercase;
            font-weight: 800;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        @media (min-width: 768px) {
            h1 { font-size: 64px; }
        }
        .subtitle {
            color: #888;
            font-size: 14px;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 4px;
        }
        /* 通用按钮样式 */
        .menu-btn {
            background: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 12px 30px;
            font-size: 18px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            transition: all 0.2s;
            font-weight: bold;
            letter-spacing: 2px;
            margin: 10px 0;
            width: 100%;
            display: block;
        }
        .menu-btn:hover, .menu-btn:active {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }
        /* 切换按钮的激活状态 */
        .toggle-active {
            background: #00ffff !important;
            color: #000 !important;
        }

        .hidden { opacity: 0; pointer-events: none; transition: opacity 0.5s; }
        .visible { opacity: 1; pointer-events: auto; transition: opacity 0.5s; }
        
        .tutorial {
            margin-top: 20px;
            color: #555;
            font-size: 12px;
            line-height: 1.5;
        }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="score-container" class="hud-text">SCORE: <span id="score">0</span></div>
        <div id="lives-container" class="hud-text">LIVES: <span id="lives">3</span></div>
    </div>

    <div id="game-menu" class="visible">
        <h1>Vortex</h1>
        <div class="subtitle">Deep Tunnel Edition</div>
        
        <button id="mode-btn" class="menu-btn">Control: Touch</button>
        <button id="start-btn" class="menu-btn" style="border-color: #ff00ff; color: #ff00ff; margin-top: 20px;">INITIATE</button>
        
        <div class="tutorial" id="tutorial-text">
            Drag to rotate paddle
        </div>
    </div>

    <script>
        // --- 配置 ---
        const CONFIG = {
            tunnelRadius: 30,
            tunnelLength: 400,
            paddleWidthAngle: 0.8,
            paddleDepth: 4,
            paddleZ: 5,
            ballRadius: 1.2,
            ballBaseSpeedZ: 1.5,
            ballBaseSpeedAng: 0.03,
            brickRows: 10,
            brickStartZ: -50,
            brickSpacingZ: 15,
            colors: [0xff0055, 0xff4400, 0xffaa00, 0xaaff00, 0x00ffaa, 0x00aaff, 0x4400ff, 0xff00aa]
        };

        // --- 全局变量 ---
        let scene, camera, renderer;
        let tunnelMesh, paddleMesh, ballMesh, ballGlow;
        let bricks = [];
        let particles = [];
        let score = 0;
        let lives = 3;
        let isGameRunning = false;
        let animationId;
        let cameraShake = 0;
        let baseCameraZ = 60;
        
        // 控制相关
        let controlMode = 'touch'; // 'touch' or 'gyro'
        let gyroEnabled = false;

        // 游戏状态
        const state = {
            paddleTheta: Math.PI / 2,
            ball: {
                theta: 0,
                z: -50,
                vTheta: 0.02,
                vZ: 1.0,
                active: false
            }
        };

        // --- 初始化 ---
        function init() {
            const container = document.getElementById('canvas-container');

            // 1. 场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050508);
            scene.fog = new THREE.Fog(0x050508, 100, CONFIG.tunnelLength - 50);

            // 2. 相机
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.lookAt(0, 0, -100);

            // 3. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // 4. 灯光
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            const light = new THREE.PointLight(0xffffff, 1, 100);
            light.position.set(0,0,0);
            scene.add(light);
            window.ballLight = light;

            // 5. 物体
            createTunnel();
            createPaddle();
            createBall();

            // 6. 事件
            window.addEventListener('resize', onResize);
            
            // 鼠标/触摸输入
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchstart', onTouchMove, { passive: false });
            
            // 陀螺仪监听
            window.addEventListener('deviceorientation', onDeviceOrientation);

            // UI 事件
            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('mode-btn').addEventListener('click', toggleControlMode);

            adjustCameraView();
            render();
        }

        // --- 陀螺仪与控制逻辑 ---

        async function toggleControlMode() {
            const btn = document.getElementById('mode-btn');
            const tutorial = document.getElementById('tutorial-text');

            if (controlMode === 'touch') {
                // 尝试切换到 Gyro
                // iOS 13+ 需要请求权限
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    try {
                        const response = await DeviceOrientationEvent.requestPermission();
                        if (response === 'granted') {
                            activateGyroMode(btn, tutorial);
                        } else {
                            alert("Gyroscope permission denied. Using touch.");
                        }
                    } catch (e) {
                        console.error(e);
                        alert("Error requesting device orientation.");
                    }
                } else {
                    // 非 iOS 13+ 或 Android，直接开启
                    activateGyroMode(btn, tutorial);
                }
            } else {
                // 切换回 Touch
                controlMode = 'touch';
                btn.innerText = "Control: Touch";
                btn.classList.remove('toggle-active');
                tutorial.innerText = "Drag to rotate paddle";
                gyroEnabled = false;
            }
        }

        function activateGyroMode(btn, tutorial) {
            controlMode = 'gyro';
            gyroEnabled = true;
            btn.innerText = "Control: Gyroscope";
            btn.classList.add('toggle-active');
            tutorial.innerText = "Tilt device to move paddle (Water drop style)";
        }

        function onDeviceOrientation(e) {
            if (!isGameRunning || controlMode !== 'gyro' || !gyroEnabled) return;

            // 获取倾斜数据
            // beta: 前后倾斜 (-180 ~ 180). 正值表示顶部向下倾斜
            // gamma: 左右倾斜 (-90 ~ 90). 正值表示向右倾斜
            let beta = e.beta;
            let gamma = e.gamma;

            if (beta === null || gamma === null) return;

            // 检测屏幕方向 (横屏/竖屏) 修正轴向
            // window.orientation 已废弃但兼容性好，screen.orientation 是新标准
            const orientation = window.orientation || 0;

            let x, y;

            if (orientation === 0 || orientation === 180) {
                // 竖屏 (Portrait)
                // 左右倾斜(Gamma) 对应屏幕 X 轴
                // 前后倾斜(Beta) 对应屏幕 Y 轴
                
                // 修正：原来 y = beta;
                // 现在改为 y = -beta;
                // 逻辑：当手机头部向下倾斜 (Beta增加)，水滴应该流向手机顶部 (屏幕上方 Y>0)。
                // 所以我们需要反转 Beta 的符号。
                x = gamma; 
                y = -beta; 
            } else if (orientation === 90) {
                // 横屏 (Landscape Left, Home键在右)
                // 此时手机的"顶部"变成了屏幕左侧
                // 前后倾斜(Beta) 变成了屏幕 X 轴
                // 左右倾斜(Gamma) 变成了屏幕 Y 轴 (且方向反转)
                
                // 修正：Beta 同样需要反转逻辑以匹配物理直觉
                // 头部向下倾斜 -> 水滴流向头部 -> 在横屏90度下，头部是屏幕左侧 (-X)
                // 原逻辑 x = beta; 改为 x = -beta? 
                // 让我们再次推导：
                // 竖屏下，头部向下(Beta>0)，我们要去顶部(Y>0)，所以 y = -(-Beta)? 不，Beta>0时我们要正值，除非Beta定义不同。
                // 经测试通常 Beta 前倾为正。如果前倾(正)要去上方(正)，则 y=beta 应该是对的...
                // 但根据你的反馈“反了”，说明在你的设备/浏览器上，前倾导致了向下移动。
                // 这意味着原来的 y=beta 产生了负值效果(或者坐标系定义不同)。
                // 所以我们强制反转它： y = -beta。
                
                // 同理横屏：
                x = -beta; 
                y = -gamma;
            } else if (orientation === -90) {
                // 横屏 (Landscape Right)
                x = beta; // 反转原来的 -beta
                y = gamma;
            }

            // 死区处理 (防止微小抖动)
            const deadzone = 5; // 度
            if (Math.abs(x) < deadzone && Math.abs(y) < deadzone) {
                return; // 保持不动
            }

            // 计算角度
            // 我们希望:
            // 倾斜向右 (x > 0) -> 角度 0
            // 倾斜向左 (x < 0) -> 角度 PI
            // 倾斜向下 (顶部抬起, y < 0) -> 角度 -PI/2 (屏幕下方)
            // 倾斜向上 (顶部下沉, y > 0) -> 角度 PI/2 (屏幕上方)
            
            let angle = Math.atan2(y, x);
            
            // 为了避免从 PI 跳变到 -PI 的插值问题，直接赋值最灵敏
            state.paddleTheta = angle;
        }

        // --- 相机适配逻辑 ---
        function adjustCameraView() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const targetVisibleHalfWidth = CONFIG.tunnelRadius + 12; 
            const distance = targetVisibleHalfWidth / (Math.tan(vFOV / 2) * aspect);
            baseCameraZ = Math.max(60, distance);
            
            camera.position.z = baseCameraZ;
        }

        // --- 物体创建函数 (保持不变) ---
        function createTunnel() {
            const geometry = new THREE.CylinderGeometry(CONFIG.tunnelRadius, CONFIG.tunnelRadius, CONFIG.tunnelLength, 32, 40, true);
            geometry.scale(-1, 1, 1); 
            geometry.rotateX(Math.PI / 2);
            geometry.translate(0, 0, -CONFIG.tunnelLength / 2 + 20);
            const material = new THREE.MeshBasicMaterial({ color: 0x222222, wireframe: true, transparent: true, opacity: 0.3 });
            tunnelMesh = new THREE.Mesh(geometry, material);
            scene.add(tunnelMesh);

            const lineGeo = new THREE.BufferGeometry();
            const points = [];
            for(let i=0; i<8; i++) {
                const angle = (i/8) * Math.PI * 2;
                const x = Math.cos(angle) * CONFIG.tunnelRadius;
                const y = Math.sin(angle) * CONFIG.tunnelRadius;
                points.push(new THREE.Vector3(x, y, 50));
                points.push(new THREE.Vector3(x, y, -CONFIG.tunnelLength));
            }
            lineGeo.setFromPoints(points);
            const lines = new THREE.LineSegments(lineGeo, new THREE.LineBasicMaterial({ color: 0x0044aa, opacity: 0.5, transparent: true }));
            scene.add(lines);
        }

        function createPaddle() {
            const arcShape = new THREE.Shape();
            const outerR = CONFIG.tunnelRadius;
            const innerR = CONFIG.tunnelRadius - 2;
            const startAng = -CONFIG.paddleWidthAngle / 2;
            const endAng = CONFIG.paddleWidthAngle / 2;
            arcShape.absarc(0, 0, outerR, startAng, endAng, false);
            arcShape.absarc(0, 0, innerR, endAng, startAng, true);
            const extrudeSettings = { depth: CONFIG.paddleDepth, bevelEnabled: false };
            const geometry = new THREE.ExtrudeGeometry(arcShape, extrudeSettings);
            const material = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x008888, metalness: 0.8, roughness: 0.2 });
            paddleMesh = new THREE.Mesh(geometry, material);
            paddleMesh.position.z = CONFIG.paddleZ;
            scene.add(paddleMesh);
        }

        function createBall() {
            const geometry = new THREE.SphereGeometry(CONFIG.ballRadius, 32, 32);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            ballMesh = new THREE.Mesh(geometry, material);
            const glowGeo = new THREE.SphereGeometry(CONFIG.ballRadius * 1.5, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending });
            ballGlow = new THREE.Mesh(glowGeo, glowMat);
            ballMesh.add(ballGlow);
            scene.add(ballMesh);
        }

        function createBricks() {
            bricks.forEach(b => scene.remove(b.mesh));
            bricks = [];
            const rows = CONFIG.brickRows;
            for (let r = 0; r < rows; r++) {
                const z = CONFIG.brickStartZ - (r * CONFIG.brickSpacingZ);
                const color = CONFIG.colors[r % CONFIG.colors.length];
                const brickCount = 8 + Math.floor(Math.random() * 4); 
                const gap = 0.2;
                const brickAngleWidth = (Math.PI * 2) / brickCount - gap;
                for (let i = 0; i < brickCount; i++) {
                    const centerAngle = i * ((Math.PI * 2) / brickCount);
                    if (Math.random() > 0.9) continue;
                    const arcShape = new THREE.Shape();
                    const outerR = CONFIG.tunnelRadius;
                    const innerR = CONFIG.tunnelRadius - 2;
                    arcShape.absarc(0, 0, outerR, -brickAngleWidth/2, brickAngleWidth/2, false);
                    arcShape.absarc(0, 0, innerR, brickAngleWidth/2, -brickAngleWidth/2, true);
                    const geometry = new THREE.ExtrudeGeometry(arcShape, { depth: 4, bevelEnabled: true, bevelSize: 0.2, bevelThickness: 0.2 });
                    const material = new THREE.MeshStandardMaterial({ color: color, metalness: 0.5, roughness: 0.1, emissive: color, emissiveIntensity: 0.3 });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.z = z;
                    mesh.rotation.z = centerAngle;
                    scene.add(mesh);
                    bricks.push({ mesh: mesh, active: true, z: z, depth: 4, angle: centerAngle, angleWidth: brickAngleWidth, color: color });
                }
            }
        }

        function createExplosion(pos, color) {
            const count = 15;
            const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            for(let i=0; i<count; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                const r = CONFIG.tunnelRadius - 2;
                mesh.position.set(Math.cos(pos.theta) * r, Math.sin(pos.theta) * r, pos.z);
                const vel = new THREE.Vector3((Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)).multiplyScalar(0.8);
                scene.add(mesh);
                particles.push({ mesh, vel, life: 1.0 });
            }
        }

        // --- 游戏逻辑核心 ---
        function resetBall() {
            state.ball.z = -50;
            state.ball.theta = Math.random() * Math.PI * 2;
            state.ball.vZ = CONFIG.ballBaseSpeedZ; 
            state.ball.vTheta = (Math.random() - 0.5) * 0.05;
            state.ball.active = true;
        }

        function startGame() {
            score = 0;
            lives = 3;
            updateUI();
            createBricks();
            resetBall();
            document.getElementById('game-menu').className = 'hidden';
            isGameRunning = true;
        }

        function gameOver() {
            isGameRunning = false;
            document.getElementById('game-menu').className = 'visible';
            document.getElementById('status-text').innerText = `GAME OVER - Score: ${score}`;
            document.getElementById('start-btn').innerText = "RETRY";
        }

        function updatePhysics() {
            if (!isGameRunning) return;
            paddleMesh.rotation.z = state.paddleTheta;

            const ball = state.ball;
            ball.z += ball.vZ;
            ball.theta += ball.vTheta;
            const playRadius = CONFIG.tunnelRadius - CONFIG.ballRadius - 0.1;
            ballMesh.position.set(Math.cos(ball.theta) * playRadius, Math.sin(ball.theta) * playRadius, ball.z);
            window.ballLight.position.copy(ballMesh.position);

            if (ball.z < -CONFIG.tunnelLength + 10) {
                ball.z = -CONFIG.tunnelLength + 10;
                ball.vZ *= -1;
                triggerShake(2);
            }

            if (ball.z > CONFIG.paddleZ - CONFIG.ballRadius) {
                let angleDiff = ball.theta - state.paddleTheta;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                if (Math.abs(angleDiff) < CONFIG.paddleWidthAngle / 2 + 0.1) {
                    ball.z = CONFIG.paddleZ - CONFIG.ballRadius - 0.5;
                    ball.vZ *= -1;
                    const hitOffset = angleDiff / (CONFIG.paddleWidthAngle / 2);
                    ball.vTheta += hitOffset * 0.02;
                    ball.vTheta = Math.max(Math.min(ball.vTheta, 0.08), -0.08);
                    ball.vZ *= 1.05;
                    ball.vZ = Math.max(Math.min(ball.vZ, 2.5), -2.5);
                    paddleMesh.material.emissiveIntensity = 1.0;
                    setTimeout(() => paddleMesh.material.emissiveIntensity = 0.3, 100);
                    triggerShake(3);
                } else {
                    if (ball.z > CONFIG.paddleZ + 10) {
                        lives--;
                        updateUI();
                        triggerShake(10);
                        if (lives <= 0) {
                            gameOver();
                        } else {
                            resetBall();
                        }
                    }
                }
            }

            for (let i = bricks.length - 1; i >= 0; i--) {
                const b = bricks[i];
                if (!b.active) continue;
                const brickZMin = b.z;
                const brickZMax = b.z + b.depth;
                if (ball.z + CONFIG.ballRadius > brickZMin && ball.z - CONFIG.ballRadius < brickZMax) {
                    let diff = ball.theta - b.angle;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    if (Math.abs(diff) < b.angleWidth / 2 + 0.1) {
                        hitBrick(i, b);
                        const prevZ = ball.z - ball.vZ;
                        if (prevZ + CONFIG.ballRadius <= brickZMin || prevZ - CONFIG.ballRadius >= brickZMax) {
                            ball.vZ *= -1;
                        } else {
                            ball.vTheta *= -1;
                        }
                        break;
                    }
                }
            }
        }

        function hitBrick(index, brick) {
            brick.active = false;
            scene.remove(brick.mesh);
            bricks.splice(index, 1);
            score += 100;
            updateUI();
            createExplosion({theta: brick.angle, z: brick.z}, brick.color);
            triggerShake(1);
            if (bricks.length === 0) {
                createBricks();
                state.ball.vZ *= 0.8;
                resetBall();
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.03;
                p.mesh.position.add(p.vel);
                p.mesh.rotation.x += 0.2;
                p.mesh.scale.setScalar(p.life);
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        function triggerShake(intensity) {
            cameraShake = intensity;
        }

        function updateCameraShake() {
            if (cameraShake > 0) {
                const rx = (Math.random() - 0.5) * cameraShake * 0.1;
                const ry = (Math.random() - 0.5) * cameraShake * 0.1;
                camera.position.set(rx, ry, baseCameraZ);
                cameraShake *= 0.9;
                if (cameraShake < 0.1) {
                    cameraShake = 0;
                    camera.position.set(0, 0, baseCameraZ);
                }
            } else {
                camera.position.z = baseCameraZ;
                camera.position.x = 0;
                camera.position.y = 0;
            }
        }

        function updateUI() {
            document.getElementById('score').innerText = score;
            document.getElementById('lives').innerText = lives;
        }

        function render() {
            animationId = requestAnimationFrame(render);
            updatePhysics();
            updateParticles();
            updateCameraShake();
            if (tunnelMesh) {
                tunnelMesh.rotation.x = Math.PI/2;
                tunnelMesh.rotation.y += 0.001; 
            }
            renderer.render(scene, camera);
        }

        function onMouseMove(e) {
            if (!isGameRunning || controlMode !== 'touch') return;
            handleInput(e.clientX, e.clientY);
        }

        function onTouchMove(e) {
            if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
            if(e.cancelable) e.preventDefault();
            if (!isGameRunning || controlMode !== 'touch') return;
            if (e.touches.length > 0) {
                handleInput(e.touches[0].clientX, e.touches[0].clientY);
            }
        }

        function handleInput(clientX, clientY) {
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 2;
            const dx = clientX - cx;
            const dy = clientY - cy;
            let angle = Math.atan2(-dy, dx);
            state.paddleTheta = angle;
        }

        function onResize() {
            adjustCameraView();
        }

        init();
    </script>
</body>
</html>
